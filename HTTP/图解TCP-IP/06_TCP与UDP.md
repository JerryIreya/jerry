![](https://raw.githubusercontent.com/JerryIreya/Image/master/ISO%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png)

TCP (Transmission Control Protocol)

UDP (User Datagram Protocol)

# 传输层的作用

TCP/IP中有两个具有代表性的传输层协议，它们分别是TCP和UDP。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。根据通信的具体特征，选择合适的传输层协议是非常重要的。

## 传输层定义

前面章节有提到，IP首部中有一个协议字段，用来标识网络层(IP)的上一层所采用的是哪一种传输层协议。根据这个字段的协议号，就可以识别IP传输的数据部分究竟是TCP的内容，还是UDP的内容。  

同样，传输层的TCP和UDP，为了识别自己所传输的数据部分究竟应该发给哪个应用，也设定了这样一个编号。  
以包裹为例，邮递员(IP)根据收件人地址(目标IP地址)向目的地(计算机)投递包裹(IP数据包)。包裹到达目的地以后由对方(传输层协议)根据包裹信息判断最终的接受人(接收端应用程序)。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/01_%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E8%A1%8C%E7%9D%80%E4%BC%97%E5%A4%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F.png)

如果快递单上只写了家庭地址和姓氏，那该如何是好呢？你根本无法判断快递究竟应该投递给哪一位家庭成员。  
在TCP/IP的通信当中也是如此，需要指定“姓氏”，即“应用程序”。而传输层必须指出这个具体的程序，为了实现这一功能，使用端口号这样一种识别码。根据端口号就可以识别在传输层上一层的应用层中所要进行处理的具体程序。

## 通信处理

再以邮递包裹为例，详细分析一下传输层的协议工作机制。

前面提到的“应用程序”其实就是用来进行TCP/IP应用协议的处理。因此，TCP/IP中所要识别的“姓氏”就可以被理解为应用协议。  
TCP/IP的众多应用协议大多以客户端/服务端的形式运行。客户端类似于客户的意思，是请求的发起端。而服务端则表示提供服务的意思，是请求的处理端。另外，作为服务端的程序有必要提前启动，准备接收客户端的请求。否则即使有客户端的请求发过来，也无法做到相应的处理。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/02_HTTP%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82.png)

这些服务端程序在UNIX系统当中叫做守护进程。例如HTTP的服务端程序是httpd(HTTP守护进程),而ssh的服务端程序是sshd(SSH守护进程)。在UNIX中并不需要将这些守护进程逐个启动，而是启动一个可以代表它们接收客户端请求的inetd(互联网守护进程)服务程序即可。它是一种超级守护进程。该超级守护进程收到客户端请求以后会创建(fork)新的进程并转换(exec)为sshd等各个守护进程。

确认一个请求究竟发给的是哪个服务端(守护进程)，可以通过所收到数据包的目标端口号轻松识别。当收到TCP的建立连接请求时，如果目标端口为22，在转给sshd，如果是80则转给httpd。然后，这些守护进程会继续对该连接上的通信传输进行处理。  
传输协议TCP、UDP通过接收数据中的目标端口号识别目标处理程序。以上图为例，传输协议的数据将被传递给HTTP、TELNET以及FTP等应用层协议。

## 两种传输层协议TCP和UDP

在TCP/IP中能够实现传输层功能的、具有代表性的协议是TCP和UDP

### TCP

TCP是面向有连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管道中的水流。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。例如，在发送端应用程序发送了10次100字节的消息，那么在接收端，应用程序有可能会收到一个1000字节连续不间断的数据。因此在TCP通信中，发送端应用可以在自己所要发送的消息中设置一个表示长度或间隔的字段信息。  
TCP为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制(流量控制)”、“拥塞控制”、提高网络利用率等众多功能。

### UDP

UDP是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在UDO的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。例如，发送端应用程序发送一个100字节的消息，那么接收端应用程序也会以100字节为长度接收数据。UDP中，消息长度的数据也会发送到接收端，因此在发送的消息中不需要设置一个表示消息长度或间隔的字段信息。然而，UDP不具备可靠传输。所以，发送端发出去的消息在网络传输途中一旦丢失，接收端将收不到这个消息。

### TCP与UDP区分

TCP用于在传输层有必要实现可靠传输的情况。由于它是面向有连接并具备顺序控制、重发控制等机制的，所以它可以为应用提供可靠传输。  
而在一方面，UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。我们举一个通过IP电话进行通话的例子。如果使用TCP，数据在传送途中如果丢失会被重发，但这样无法流畅地传输通话人的声音，会导致无法进行正常交流。而采用UDP，它不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只是会影响某一小部分的通话(在实时传送动画或声音时，途中一小部分的丢包可能会导致画面或声音的短暂停顿甚至出现混乱。但在实际使用当中，这一点干扰并无大碍)。此外，在多播与广播通信中也使用UDP而不是TCP。

因此，TCP和UDP应该根据应用的目的按需使用。

### 套接字(Socket)

应用在使用TCP或UDP时，会用到操作系统提供的类库。这种类库一般被称为API。  
使用TCP或UDP通信时，又会广泛使用到套接字(socket)的API。  
应用程序利用套接字，可以设置对端的IP地址、端口号，并实现数据的发送与接收。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/03_Socket.png)

# 端口号

## 端口号定义

数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互联的主机和路由器。在传输层中也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。  

## 根据端口号识别应用

一台计算机上同时可以运行多个程序。例如接受WWW服务的Web浏览器、点有客户端、远程登录用的ssh客户端等程序都可同时运行。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/04_%E6%A0%B9%E6%8D%AE%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%AF%86%E5%88%AB%E5%BA%94%E7%94%A8.png)

## 通过IP地址、端口号、协议号进行通信识别

仅凭目标端口识别某一个通信是远远不够的。  

如下图所示，①和②的通信是在两台计算机上进行的。它们的目标端口号相同，都是80.例如打开两个Web浏览器，同时访问两个服务器上不同的页面，就会在这个浏览器跟服务器之间产生类似前面的两个通信。在这种情况下也必须严格区分这两个通信。因此可以根据源端口号加以区分。  
下图中③跟①的目标端口号和源端口号完全相同，但是它们各自的源IP地址不同。此外，还有一种情况图中并未列出，那就是IP地址和端口号全都一样，只是协议号(表示上层是TCP或UDP的一种编号)不同。这种情况下，也会认为是两个不同的通信。  
因此，TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口号”。只要其中某一项不同，则被认为是其他通信。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/05_%E8%AF%86%E5%88%AB%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82.png)


# UDP

## UDP的特点及其目的

UDP是User Datagram Protocol的缩写。

UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。

即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交由采用UDP的应用程序去处理。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。

由于UDP面向无连接，它可以随时发送数据。再加上UDP本身的处理既简单又高效，因此经常用于以下几个方面：

* 包总量较少的通信(DNS,SNMP等)
* 视频、音频等多媒体通信(即使通信)
* 限定于LAN等特定网络中的应用通信
* 广播通信


# TCP

UDP是一种没有复杂控制，提供面向无连接通信服务的一种协议。换句话说，它将部分控制转义给应用程序去处理，自己却只提供作为传输层协议的最基本功能。  
与UDP不同，TCP则“人如其名”，可以说是对“传输、发送、通信”进行“控制”的“协议”。  
TCP与UDP的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。  
根据TCP的这些机制，在IP这种无连接的网络上也能够实现高可靠性的通信。

## TCP的特点及其目的

为了通过IP数据报实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。

TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。

## 通过序列号与确认应答提高可靠性

在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答(ACK:Positive Acknowledgement)。

正常的数据传输：

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/06_%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.png)

TCP通过肯定的确认应答(ACK)实现可靠的数据传输。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。  

如下图所示，在一定时间内没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。  

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/07_%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5.png)

未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端因没有收到确认应答而认为数据没有到达目的地，从而进行重新发送。如下图所示：

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/08_%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5.png)

此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源发送主机只要按照机制重发数据即可。但是对于目标主机来说，这简直是一种“灾难”。它会反复收到相同的数据。而为了对上层应用提供可靠的传输，必须得放弃重复的数据包。为此，就必须引入一种机制，它能够识别是否已经接收数据，又能够判断是否需要接收。


上述这些确认应答处理、重发控制以及重复控制等功能都可以通过序列号实现。序列号是按顺序给发送数据的每一个字节(8位)都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。就这样，通过序列号和确认应答号，TCP可以实现可靠传输。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/图解TCP-IP/Chapter06/09_发送数据.png)


## 连接管理

TCP提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好通信两端之间的准备工作。

UDP是一种面向无连接的通信协议，因此不检查对端是否可以通信，直接将UDP包发送出去。TCP与此相反，它会在数据通信之前，通过TCP首部发送一个 **SYN包(TCP中发送第一个SYN包的一方叫做客户端，接收这个包的一方叫做服务端)** 作为建立连接的请求等待确认应答。如果对端发来确认应答，则认为可以进行数据通信。如果对端的确认应答未能到达，就不会进行数据通信。此外，在通信结束时会进行断开连接的处理(**FIN包**)

可以使用TCP首部用于控制的字段来管理TCP连接。一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成。(建立一个TCP连接需要发送3个包，这个过程也称作“三次握手”)

> **TCP连接的建立与断开**

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/10_TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80.png)

## TCP以段为单位发送数据

在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为"最大消息长度"(MSS:Maxiumum Segment Size)。最理想的情况是，最大消息长度正好是IP中不会被被分片处理的最大数据长度。  
TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位。  
MSS是在三次握手的时候，在两端主机之间被计算得出的。两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小。然后会在两者之间选择一个较小的值投入使用。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/11_%E8%AE%A1%E7%AE%97MSS.png)

## 利用窗口控制提高速度

TCP以1个段为单位，每发一个段进行一次确认应答的处理，如下图所示。这样的传输方式有一个缺点。那就是，包的往返时间越长通信性能就越低。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/12_%E6%8C%89%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94.png)


为解决这个问题，TCP引入了窗口这个概念。即使在往返时间较长的情况下，它也能控制网络性能的下降。下图所示，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短。也就是说，发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/13_%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%96%B9%E5%BC%8F%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86.png)

窗口大小就是指无序等待确认应答而可以继续发送数据的最大值。上图中，窗口大小为4个段。  
这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。

如下图所示，发送数据中高亮圈起的部分正是前面所提到的窗口。在这个窗口内的数据即便没有收到确认应答也可以发送出去。此外，从窗口中能看到的数据因其某种数据已在传输中丢失，所以发送端不能收到的确认应答，这种情况也需要进行重发。为此，发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/14_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%96%B9%E5%BC%8F.png)

在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。  
收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也被称为滑动窗口控制。


## 窗口控制与重发控制

在使用窗空控制中，如果出现段丢失该怎么办？

首先，我们先考虑一种情况：数据已经到达对端，但是确认应答却在返回的途中丢失，即发送端未能收到接收端的确认应答。这种情况下，是没有必要进行重发的。然而，在没用使用窗口控制时，没有收到确认应答的数据都会被重发。而使用了窗口控制，就如下图所示，某些确认应答即便丢失也无需重发。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/15_%E6%B2%A1%E6%9C%89%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E4%B9%9F%E4%B8%8D%E5%8F%97%E5%BD%B1%E5%93%8D.png)

其次，我们来考虑一下每个报文段丢失的情况。如下图所示，接收端主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答。

如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像实在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作高速重发控制。

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/16_%E9%AB%98%E9%80%9F%E9%87%8D%E5%8F%91%E6%8E%A7%E5%88%B6.png)

## 流控制

发送端根据自己的实际情况发送数据。但是，接收端可能收到的是一个毫无关系的数据包又可能会在处理其他问题上花费一些时间。因此在为这个数据包做其他处理时会耗费一些时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本应该接收的数据丢弃的话，就又会出发重发机制，从而导致网络流量的无端浪费。  
为了防止这种现象的发生，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称作窗口大小。前面所介绍的窗口大小的值就是由接收端主机决定的。  
TCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段的值越大，说明网络的吞吐量越高。  
不过，接收端的这个缓冲区一旦面临数据溢出时，窗口大小的指也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也就形成了一个完整的TCP流控制(流量控制)。  
下图为根据窗口大小控制流量过程的实例：

![](https://raw.githubusercontent.com/JerryIreya/Image/master/%E5%9B%BE%E8%A7%A3TCP-IP/Chapter06/17_%E6%B5%81%E6%8E%A7%E5%88%B6.png)

如上图所示，当接收端收到从3001号开始的数据段后其缓冲区即满，不得不暂时停止接收数据。之后，在收到发送窗口更新通知后通信才得以继续进行。如果这个窗口的更新通知在传送途中丢失，可能会导致无法继续通信。为避免此类问题的发生，发送端主机会不时的发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小的信息。  
